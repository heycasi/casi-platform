// src/lib/multilingual.ts - Comprehensive Language Support

export interface LanguageDetection {
  language: string
  confidence: number
  isQuestion: boolean
  sentiment: 'positive' | 'negative' | 'neutral'
  questionType?: string
  sentimentReasons?: string[]
}

// Question words by language
const QUESTION_WORDS = {
  english: ['what', 'how', 'when', 'where', 'why', 'who', 'which', 'whose', 'whom'],
  spanish: ['qu√©', 'que', 'c√≥mo', 'como', 'cu√°ndo', 'cuando', 'd√≥nde', 'donde', 'por qu√©', 'por que', 'qui√©n', 'quien', 'cu√°l', 'cual'],
  french: ['quoi', 'comment', 'quand', 'o√π', 'ou', 'pourquoi', 'qui', 'quel', 'quelle', 'quels', 'quelles'],
  german: ['was', 'wie', 'wann', 'wo', 'warum', 'wer', 'welche', 'welcher', 'welches'],
  portuguese: ['o que', 'que', 'como', 'quando', 'onde', 'por que', 'porque', 'quem', 'qual'],
  italian: ['cosa', 'come', 'quando', 'dove', 'perch√©', 'perche', 'chi', 'quale', 'quali'],
  dutch: ['wat', 'hoe', 'wanneer', 'waar', 'waarom', 'wie', 'welke'],
  japanese: ['‰Ωï', '„Å™„Å´', '„Å™„Çì', '„Å©„ÅÜ', '„ÅÑ„Å§', '„Å©„Åì', '„Å™„Åú', '„Å†„Çå', '„Å©„Çå', '„Å©„ÅÆ'],
  korean: ['Î≠ê', 'Î¨¥Ïóá', 'Ïñ¥ÎñªÍ≤å', 'Ïñ∏Ï†ú', 'Ïñ¥Îîî', 'Ïôú', 'ÎàÑÍµ¨', 'Ïñ¥Îäê'],
  chinese: ['‰ªÄ‰πà', 'ÊÄé‰πà', '‰ªÄ‰πàÊó∂ÂÄô', 'Âì™Èáå', '‰∏∫‰ªÄ‰πà', 'Ë∞Å', 'Âì™‰∏™'],
  russian: ['—á—Ç–æ', '–∫–∞–∫', '–∫–æ–≥–¥–∞', '–≥–¥–µ', '–ø–æ—á–µ–º—É', '–∫—Ç–æ', '–∫–∞–∫–æ–π', '–∫–∞–∫–∞—è'],
  arabic: ['ŸÖÿß', 'ŸÉŸäŸÅ', 'ŸÖÿ™Ÿâ', 'ÿ£ŸäŸÜ', 'ŸÑŸÖÿßÿ∞ÿß', 'ŸÖŸÜ', 'ÿ£Ÿä'],
  hindi: ['‡§ï‡•ç‡§Ø‡§æ', '‡§ï‡•à‡§∏‡•á', '‡§ï‡§¨', '‡§ï‡§π‡§æ‡§Å', '‡§ï‡•ç‡§Ø‡•ã‡§Ç', '‡§ï‡•å‡§®', '‡§ï‡•å‡§® ‡§∏‡§æ']
}

// Sentiment words by language
const SENTIMENT_WORDS = {
  english: {
    positive: ['good', 'great', 'awesome', 'amazing', 'excellent', 'perfect', 'love', 'best', 'cool', 'nice', 'fantastic', 'brilliant', 'wonderful', 'outstanding', 'incredible'],
    negative: ['bad', 'terrible', 'awful', 'horrible', 'hate', 'worst', 'stupid', 'boring', 'lame', 'trash', 'garbage', 'annoying', 'frustrating', 'disappointing']
  },
  spanish: {
    positive: ['bueno', 'genial', 'incre√≠ble', 'excelente', 'perfecto', 'amor', 'mejor', 'guay', 'fant√°stico', 'maravilloso', 'estupendo'],
    negative: ['malo', 'terrible', 'horrible', 'odio', 'peor', 'est√∫pido', 'aburrido', 'basura', 'molesto', 'frustrante']
  },
  french: {
    positive: ['bon', 'g√©nial', 'incroyable', 'excellent', 'parfait', 'amour', 'meilleur', 'cool', 'fantastique', 'merveilleux', 'formidable'],
    negative: ['mauvais', 'terrible', 'horrible', 'd√©teste', 'pire', 'stupide', 'ennuyeux', 'nul', 'aga√ßant', 'frustrant']
  },
  german: {
    positive: ['gut', 'toll', 'unglaublich', 'ausgezeichnet', 'perfekt', 'liebe', 'beste', 'cool', 'fantastisch', 'wunderbar', 'gro√üartig'],
    negative: ['schlecht', 'schrecklich', 'furchtbar', 'hasse', 'schlechteste', 'dumm', 'langweilig', 'm√ºll', 'nervig', 'frustrierend']
  },
  portuguese: {
    positive: ['bom', '√≥timo', 'incr√≠vel', 'excelente', 'perfeito', 'amor', 'melhor', 'legal', 'fant√°stico', 'maravilhoso'],
    negative: ['ruim', 'terr√≠vel', 'horr√≠vel', 'odeio', 'pior', 'est√∫pido', 'chato', 'lixo', 'irritante', 'frustrante']
  },
  italian: {
    positive: ['buono', 'fantastico', 'incredibile', 'eccellente', 'perfetto', 'amore', 'migliore', 'figo', 'meraviglioso'],
    negative: ['cattivo', 'terribile', 'orribile', 'odio', 'peggiore', 'stupido', 'noioso', 'spazzatura', 'fastidioso']
  },
  dutch: {
    positive: ['goed', 'geweldig', 'ongelofelijk', 'uitstekend', 'perfect', 'liefde', 'beste', 'cool', 'fantastisch'],
    negative: ['slecht', 'verschrikkelijk', 'afschuwelijk', 'haat', 'ergste', 'dom', 'saai', 'rotzooi', 'irritant']
  },
  japanese: {
    positive: ['ËâØ„ÅÑ', '„ÅÑ„ÅÑ', '„Åô„Åî„ÅÑ', 'Á¥†Êô¥„Çâ„Åó„ÅÑ', 'ÂÆåÁíß', 'ÊÑõ', 'ÊúÄÈ´ò', '„Åã„Å£„Åì„ÅÑ„ÅÑ', 'Á¥†Êïµ'],
    negative: ['ÊÇ™„ÅÑ', '„Å≤„Å©„ÅÑ', 'ÊúÄÊÇ™', 'Â´å„ÅÑ', '„Å§„Åæ„Çâ„Å™„ÅÑ', '„ÇÄ„Åã„Å§„Åè', '„ÅÜ„Åñ„ÅÑ']
  },
  korean: {
    positive: ['Ï¢ãÎã§', 'Ï¢ãÏùÄ', 'ÎåÄÎ∞ï', 'ÏµúÍ≥†', 'ÏôÑÎ≤Ω', 'ÏÇ¨Îûë', 'Î©ãÏûàÎã§', 'ÏòàÏÅòÎã§', 'ÌõåÎ•≠ÌïòÎã§'],
    negative: ['ÎÇòÏÅòÎã§', 'ÎÇòÏÅú', 'ÏµúÏïÖ', 'Ïã´Îã§', 'ÏßÄÎ£®ÌïòÎã§', 'ÏßúÏ¶ù', 'Î≥ÑÎ°ú']
  },
  chinese: {
    positive: ['Â•Ω', 'ÂæàÂ•Ω', 'Ê£í', 'ÂÆåÁæé', 'Áà±', 'ÊúÄÂ•Ω', 'ÈÖ∑', 'Â§™Ê£í‰∫Ü', '‰ºòÁßÄ'],
    negative: ['Âùè', 'Á≥üÁ≥ï', 'ÊúÄÂùè', 'ËÆ®Âéå', 'Êó†ËÅä', 'ÁÉ¶‰∫∫', 'Â∑Æ']
  },
  russian: {
    positive: ['—Ö–æ—Ä–æ—à–æ', '–æ—Ç–ª–∏—á–Ω–æ', '–ø—Ä–µ–∫—Ä–∞—Å–Ω–æ', '–∏–¥–µ–∞–ª—å–Ω–æ', '–ª—é–±–æ–≤—å', '–ª—É—á—à–∏–π', '–∫—Ä—É—Ç–æ', '–∑–∞–º–µ—á–∞—Ç–µ–ª—å–Ω–æ'],
    negative: ['–ø–ª–æ—Ö–æ', '—É–∂–∞—Å–Ω–æ', '–æ—Ç–≤—Ä–∞—Ç–∏—Ç–µ–ª—å–Ω–æ', '–Ω–µ–Ω–∞–≤–∏–∂—É', '—Ö—É–¥—à–∏–π', '–≥–ª—É–ø–æ', '—Å–∫—É—á–Ω–æ', '—Ä–∞–∑–¥—Ä–∞–∂–∞–µ—Ç']
  },
  arabic: {
    positive: ['ÿ¨ŸäÿØ', 'ŸÖŸÖÿ™ÿßÿ≤', 'ÿ±ÿßÿ¶ÿπ', 'ŸÖÿ´ÿßŸÑŸä', 'ÿ≠ÿ®', 'ÿ£ŸÅÿ∂ŸÑ', 'ÿ±ŸáŸäÿ®', 'ÿπÿ∏ŸäŸÖ'],
    negative: ['ÿ≥Ÿäÿ°', 'ŸÅÿ∏Ÿäÿπ', 'ŸÖÿ±Ÿàÿπ', 'ÿ£ŸÉÿ±Ÿá', 'ÿ£ÿ≥Ÿàÿ£', 'ÿ∫ÿ®Ÿä', 'ŸÖŸÖŸÑ', 'ŸÖÿ≤ÿπÿ¨']
  }
}

// Universal sentiment indicators (emojis work across all languages)
const EMOJI_SENTIMENT = {
  positive: ['üòä', 'üòÑ', 'üòÜ', 'ü§£', 'üòÇ', 'ü•∞', 'üòç', 'ü§©', 'üòé', 'üëç', 'üëè', 'üî•', 'üíØ', '‚ù§Ô∏è', 'üíï', '‚ú®', 'üéâ', 'ü•≥', 'üôå', 'üí™'],
  negative: ['üò¢', 'üò≠', 'üòû', 'üòî', 'üòí', 'üò§', 'üò†', 'üò°', 'ü§¨', 'üëé', 'üíî', 'üò©', 'üò´', 'üôÑ', 'üò¨', 'üò∞', 'üò®', 'üò±']
}

// Question indicators that work across languages
const UNIVERSAL_QUESTION_INDICATORS = ['?', 'Ôºü', 'ÿü'] // Latin, Japanese/Chinese, Arabic question marks

export function detectLanguageAndAnalyze(message: string): LanguageDetection {
  const normalizedMessage = message.toLowerCase().trim()
  
  // Detect primary language
  const detectedLanguage = detectPrimaryLanguage(normalizedMessage)
  
  // Check if it's a question
  const questionAnalysis = detectQuestion(normalizedMessage, detectedLanguage)
  
  // Analyze sentiment
  const sentimentAnalysis = analyzeSentiment(normalizedMessage, detectedLanguage)
  
  return {
    language: detectedLanguage,
    confidence: calculateConfidence(normalizedMessage, detectedLanguage),
    isQuestion: questionAnalysis.isQuestion,
    questionType: questionAnalysis.type,
    sentiment: sentimentAnalysis.sentiment,
    sentimentReasons: sentimentAnalysis.reasons
  }
}

function detectPrimaryLanguage(message: string): string {
  const scores: { [key: string]: number } = {}
  
  // Check each language for matching words
  Object.entries(QUESTION_WORDS).forEach(([language, words]) => {
    scores[language] = 0
    words.forEach(word => {
      if (message.includes(word)) {
        scores[language] += word.length // Longer words get higher scores
      }
    })
  })
  
  // Also check sentiment words
  Object.entries(SENTIMENT_WORDS).forEach(([language, categories]) => {
    if (!scores[language]) scores[language] = 0
    
    [...categories.positive, ...categories.negative].forEach(word => {
      if (message.includes(word)) {
        scores[language] += word.length
      }
    })
  })
  
  // Check for non-Latin scripts
  if (/[\u4e00-\u9fff]/.test(message)) scores['chinese'] = (scores['chinese'] || 0) + 10
  if (/[\u3040-\u309f\u30a0-\u30ff]/.test(message)) scores['japanese'] = (scores['japanese'] || 0) + 10
  if (/[\uac00-\ud7af]/.test(message)) scores['korean'] = (scores['korean'] || 0) + 10
  if (/[\u0600-\u06ff]/.test(message)) scores['arabic'] = (scores['arabic'] || 0) + 10
  if (/[\u0900-\u097f]/.test(message)) scores['hindi'] = (scores['hindi'] || 0) + 10
  if (/[\u0400-\u04ff]/.test(message)) scores['russian'] = (scores['russian'] || 0) + 10
  
  // Find language with highest score
  const maxScore = Math.max(...Object.values(scores))
  const detectedLanguage = Object.keys(scores).find(lang => scores[lang] === maxScore)
  
  return detectedLanguage || 'english' // Default to English
}

function detectQuestion(message: string, language: string): { isQuestion: boolean; type?: string } {
  // Check for universal question marks
  const hasQuestionMark = UNIVERSAL_QUESTION_INDICATORS.some(mark => message.includes(mark))
  
  // Check for language-specific question words
  const questionWords = QUESTION_WORDS[language] || QUESTION_WORDS.english
  const hasQuestionWord = questionWords.some(word => message.includes(word))
  
  // Determine question type
  let questionType: string | undefined
  if (hasQuestionWord || hasQuestionMark) {
    if (questionWords.some(word => ['what', 'qu√©', 'quoi', 'was', 'o que', 'cosa', 'wat', '‰Ωï'].includes(word) && message.includes(word))) {
      questionType = 'what'
    } else if (questionWords.some(word => ['how', 'c√≥mo', 'comment', 'wie', 'como', 'come', 'hoe', '„Å©„ÅÜ'].includes(word) && message.includes(word))) {
      questionType = 'how'
    } else if (questionWords.some(word => ['when', 'cu√°ndo', 'quand', 'wann', 'quando', 'wanneer', '„ÅÑ„Å§'].includes(word) && message.includes(word))) {
      questionType = 'when'
    } else if (questionWords.some(word => ['where', 'd√≥nde', 'o√π', 'wo', 'onde', 'dove', 'waar', '„Å©„Åì'].includes(word) && message.includes(word))) {
      questionType = 'where'
    } else if (questionWords.some(word => ['why', 'por qu√©', 'pourquoi', 'warum', 'por que', 'perch√©', 'waarom', '„Å™„Åú'].includes(word) && message.includes(word))) {
      questionType = 'why'
    } else if (questionWords.some(word => ['who', 'qui√©n', 'qui', 'wer', 'quem', 'chi', 'wie', '„Å†„Çå'].includes(word) && message.includes(word))) {
      questionType = 'who'
    } else {
      questionType = 'general'
    }
  }
  
  return {
    isQuestion: hasQuestionMark || hasQuestionWord,
    type: questionType
  }
}

function analyzeSentiment(message: string, language: string): { sentiment: 'positive' | 'negative' | 'neutral'; reasons: string[] } {
  const reasons: string[] = []
  let positiveScore = 0
  let negativeScore = 0
  
  // Check language-specific sentiment words
  const sentimentDict = SENTIMENT_WORDS[language] || SENTIMENT_WORDS.english
  
  sentimentDict.positive.forEach(word => {
    if (message.includes(word)) {
      positiveScore += 1
      reasons.push(`Positive word: "${word}"`)
    }
  })
  
  sentimentDict.negative.forEach(word => {
    if (message.includes(word)) {
      negativeScore += 1
      reasons.push(`Negative word: "${word}"`)
    }
  })
  
  // Check universal emoji sentiment
  EMOJI_SENTIMENT.positive.forEach(emoji => {
    if (message.includes(emoji)) {
      positiveScore += 1
      reasons.push(`Positive emoji: ${emoji}`)
    }
  })
  
  EMOJI_SENTIMENT.negative.forEach(emoji => {
    if (message.includes(emoji)) {
      negativeScore += 1
      reasons.push(`Negative emoji: ${emoji}`)
    }
  })
  
  // Determine overall sentiment
  let sentiment: 'positive' | 'negative' | 'neutral'
  if (positiveScore > negativeScore) {
    sentiment = 'positive'
  } else if (negativeScore > positiveScore) {
    sentiment = 'negative'
  } else {
    sentiment = 'neutral'
  }
  
  return { sentiment, reasons }
}

function calculateConfidence(message: string, detectedLanguage: string): number {
  // Simple confidence calculation based on how many language-specific elements we found
  const questionWords = QUESTION_WORDS[detectedLanguage] || []
  const sentimentWords = SENTIMENT_WORDS[detectedLanguage] || { positive: [], negative: [] }
  
  let matches = 0
  const totalWords = message.split(' ').length
  
  questionWords.forEach(word => {
    if (message.includes(word)) matches++
  })
  
  ;[...sentimentWords.positive, ...sentimentWords.negative].forEach(word => {
    if (message.includes(word)) matches++
  })
  
  // Higher confidence for more matches relative to message length
  return Math.min(0.95, Math.max(0.3, matches / totalWords))
}

// Enhanced message analysis function for the dashboard
export function analyzeMessage(username: string, messageText: string): {
  id: string
  username: string
  message: string
  timestamp: Date
  sentiment: 'positive' | 'negative' | 'neutral'
  isQuestion: boolean
  priority: number
  language: string
  confidence: number
  questionType?: string
  sentimentReasons?: string[]
} {
  const analysis = detectLanguageAndAnalyze(messageText)
  
  // Calculate priority (questions get higher priority)
  let priority = Math.floor(Math.random() * 6) + 1
  if (analysis.isQuestion) {
    priority = Math.floor(Math.random() * 3) + 8 // 8-10 for questions
  }
  if (analysis.sentiment === 'negative') {
    priority += 1 // Boost negative sentiment priority
  }
  
  return {
    id: Date.now().toString() + Math.random(),
    username,
    message: messageText,
    timestamp: new Date(),
    sentiment: analysis.sentiment,
    isQuestion: analysis.isQuestion,
    priority,
    language: analysis.language,
    confidence: analysis.confidence,
    questionType: analysis.questionType,
    sentimentReasons: analysis.sentimentReasons
  }
}
